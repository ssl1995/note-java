## 布隆过滤器用户集合的建立与查询，并可以节省大量空间

## 一致性哈希解决数据服务器的负载均衡问题

## 利用并查集结构做岛问题的并行计算

## 哈希函数可以把数据按照种类均匀分流

问题：32位无符号整数的范围是0-2^32-1,现在有一个正好包含40亿个无符号整数的文件，可以使用最多1GB的内存，怎么找到出现次数最多的数？
思考：**1GB=2^10 MB = 2^20 KB =2^30 B 约等于 10亿B**
    错误：如果内存排序，40亿无符号整数需要申请40亿*(2^32-1)=160亿B的数组，所以需要16G内存。但是我只有1G内存，需要不行。
    错误：如果哈希表统计次数，极端情况，40亿数都不相同，哈希表表存8字节整数的键值对，需要32G内存，更不好。
正确：计算1G存8B的哈希表，1G内存 = 2^30B,8B=2^3,最多是2^30/8 = 2^27 约等于 1亿个哈希表（假设还有其他消耗，也可以取1千万）

1. 假设选择1千万个哈希表，40亿个数 / 1千万 = 400次 = 用400个文件夹。让任何一个数通过哈希函数算出一个值，再%400，放入不同的文件夹
2. 由于哈希函数均匀性，任意一个文件夹的数字种数均匀分为 1千万个，然后在某个小文件夹里排序统计该文件夹出现最多的数。
3. 汇总，得到这40亿个数中出现次数最多的数。

问题：32位无符号整数的范围是0-2^32-1 = 42亿左右,现在有一个正好包含40亿个无符号整数的文件，最多可以使用1G内存，怎么找到所有没出现过的数？
错误：如果使用Set统计，和上一题分析是一样的，需要16G内存，肯定不行
正确：使用位图，32位无符号整数的范围2^32-1 =42亿，使用一个能存储42亿的位图，比如bit[2^32]数组
2^32/2^3=2^29B < 1G=2^30B，所以可以使用1G内存存在40亿个无符号整数。
怎么使用bit[2^32]数组？使用int类型去拼，1个int=4B =32bit=2^5,
bit[2^32] = int[2^32/2^5=2^27]存储40亿无符号整数，出现过的数字对应的位图位置描黑，位置下标=num/32，描黑位置 int[num/32] |= 1<< num%32
 
进阶1：如果是3KB内存，怎么1个未出现的数字 ？
解答：3KB，可以生成int[(3kB=3000B)/4B=750],选择<=750的2的多少次方，是2^9=512
(2^32 - 1)/512 = 8300608个
2的32次方，是：4294967296
分成了512份，所以每一份是：8388608
arr[0] : 表示 0 ~ 8388607 范围上的数字出现几次
arr[1] : 表示 8388608 ~ 16777215 范围上的数字出现几次
arr[2] : 表示16777216 ~ 25165823 范围上的数字出现几次
arr[i] ：表示 i * 8388608 ~ ( (i + 1) * 8388608 ) - 1 范围上的数字出现几次
…
当你遍历文件，得到一个数X，
X / 8388608，假设等于Y
arr[Y]++
这样就把X，归属于了该去的范围，然后计数+1了。

进阶2：如果只使用有限几个变量，怎么找到1个未出现的数字
解答：疯狂2分













## 位图解决某一范围上数字的出现情况，并可以节省大量空间

## 利用分段统计思想、并进一步节省大量空间

## 利用堆、外排序来做多个处理单元的结果合并
