## 布隆过滤器用户集合的建立与查询，并可以节省大量空间

## 一致性哈希解决数据服务器的负载均衡问题

## 利用并查集结构做岛问题的并行计算

## 哈希函数可以把数据按照种类均匀分流

问题：32位无符号整数的范围是0-2^32-1,现在有一个正好包含40亿个无符号整数的文件，可以使用最多1GB的内存，怎么找到出现次数最多的数？
思考：**1GB=2^10 MB = 2^20 KB =2^30 B 约等于 10亿B**
    错误：如果内存排序，40亿无符号整数需要申请40亿*(2^32-1)=160亿B的数组，所以需要16G内存。但是我只有1G内存，需要不行。
    错误：如果哈希表统计次数，极端情况，40亿数都不相同，哈希表表存8字节整数的键值对，需要32G内存，更不好。
正确：计算1G存8B的哈希表，1G内存 = 2^30B,8B=2^3,最多是2^30/8 = 2^27 约等于 1亿个哈希表（假设还有其他消耗，也可以取1千万）

1. 假设选择1千万个哈希表，40亿个数 / 1千万 = 400次 = 用400个文件夹。让任何一个数通过哈希函数算出一个值，再%400，放入不同的文件夹
2. 由于哈希函数均匀性，任意一个文件夹的数字种数均匀分为 1千万个，然后在某个小文件夹里排序统计该文件夹出现最多的数。
3. 汇总，得到这40亿个数中出现次数最多的数。

## 位图解决某一范围上数字的出现情况，并可以节省大量空间
问题：32位无符号整数的范围是0-2^32-1 = 42亿左右,现在有一个正好包含40亿个无符号整数的文件，最多可以使用1G内存，怎么找到所有没出现过的数？
错误：如果使用Set统计，和上一题分析是一样的，需要16G内存，肯定不行
正确：使用位图，32位无符号整数的范围2^32-1 =42亿，使用一个能存储42亿的位图，比如bit[2^32]数组
2^32/2^3=2^29B < 1G=2^30B，所以可以使用1G内存存在40亿个无符号整数。
怎么使用bit[2^32]数组？使用int类型去拼，1个int=4B =32bit=2^5,
bit[2^32] = int[2^32/2^5=2^27]存储40亿无符号整数，出现过的数字对应的位图位置描黑，位置下标=num/32，描黑位置 int[num/32] |= 1<< num%32

进阶1：如果是3KB内存，怎么1个未出现的数字 ？
解答：3KB，可以生成int[(3kB=3000B)/4B=750],选择<=750的2的多少次方，是2^9=512
(2^32 - 1)/512 = 8300608个
2的32次方，是：4294967296
分成了512份，所以每一份是：8388608
arr[0] : 表示 0 ~ 8388607 范围上的数字出现几次
arr[1] : 表示 8388608 ~ 16777215 范围上的数字出现几次
arr[2] : 表示16777216 ~ 25165823 范围上的数字出现几次
arr[i] ：表示 i * 8388608 ~ ( (i + 1) * 8388608 ) - 1 范围上的数字出现几次
…
当你遍历文件，得到一个数X，
X / 8388608，假设等于Y
arr[Y]++
这样就把X，归属于了该去的范围，然后计数+1了。

进阶2：如果只使用有限几个变量，怎么找到1个未出现的数字
解答：疯狂2分

## 利用分段统计思想、并进一步节省大量空间

问题：有一个包含100亿个URL的大文件，假设每个URL占用64B，找出重复的URL？
解答：可以有失误率，用布隆过滤器；不能有失误率，用哈希函数分流

问题：现在有40亿个无符号无符号整数，最多使用1G内存找出出现2个的整数？
解答：还是位图，2位表示一个数，00表示出现0次，01表示出现1次，10表示出现2次，11表示出现3次及以上

问题：32位无符号整数的范围是42亿，现在有40亿个无符号整数，可以使用最多10MB内存，怎么找到40亿个数的中位数？
解答：极端一点如果内存是3KB，3KB，可以生成int[(3kB=3000B)/4B=750],选择<=750的2的多少次方，是2^9=512
中位数，我们可以取上中位数，40亿个数可以找到第20亿的数的分组，再做详细查找

## 利用堆、外排序来做多个处理单元的结果合并

问题：32位无符号整数的范围是42亿，有一个10G大小的文件，每一行都装着这种类型的数字，整个文件都是无序的，给你5G的内存空间，请输出一个10G大小的文件=原文件所有数字排序的结果
解答：大根堆！假设一个大根堆需要4+8=12B记录，，假设一个大根堆维持3个数组排序，5G内存 = 5*2^30B * 3 /12B=11W个，每次可以遍历得到11W个数排序及其出现的次数的结果
疯狂遍历40亿数就行 
